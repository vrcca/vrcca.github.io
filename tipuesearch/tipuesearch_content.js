var tipuesearch = {"pages": [{"url": "https://vrcca.github.io/post/writing-better-tests-in-java/", "text": "Ever wondered why your tests break everytime you change production code? Are your tests difficult to read? This usually happens due to tests being too attached to the corresponding implementation. I will show a few techniques on how to writte better tests in Java. PS.: I will call \u00abProduction Code\u00bb, the code that you write to make your tests pass. Changing Production Code Breaks Many Tests When your tests are too specific and bound to its implementation, you will notice that any changes to the production code such as extracting a method , extracting a class , and others, breaks your unit tests. This is a sympton of fragile tests . However, when you change behaviour or business rules, broken tests are expected. Nevertheless, your tests should not break when you change a variable from Integer to Double . Builder Pattern To The Rescue A way to avoid getting broken tests every time is to keep your unit tests as high level as possible, trying to keep it as disconnected as possible from its implementation. Here is an example of fragile test: public class AccountTest {\n    @Test\n    public void shouldCorrectlyDebitAValue() {\n        final Account account = new Account(1L, new BigDecimal(10));\n        final Account updatedAccount = account.debit(new BigDecimal(3));\n        assertThat(updatedAccount.getTotal(), is(new BigDecimal(7)));\n    }\n} As you can see, there are many details in this code: an account has a Long value, to create it you use a constructor, passing its arguments in the given order. If you change any of these, your tests will break. However, you just want to document Whenever an account debit an amount, it returns the account with updated total. You don\u2019t care about how an account is created, what are its internals. You just want an account with some cash in it, you want to subtract and then check that it correctly calculates the debit. Using the Builder Pattern , we can avoid all this: import static com.github.vrcca.domain.account.AccountTestBuilder.anAccount;\npublic class AccountTest {\n    @Test\n    public void shouldCorrectlyDebitAValue() {\n        final Account account = anAccount().withTotal(10).build();\n        final Account updatedAccount = account.debit(new BigDecimal(3));\n        assertThat(updatedAccount.getTotal(), is(new BigDecimal(7)));\n    }\n} As you can see, there is no detail on how an Account is created. Just pure high level data. You don\u2019t need to define parameters, no need to think about ordering, types. Just plain data. If we ever change the way an Account is created, we don\u2019t have to change all the tests. All we have to do is to fix our AccountTestBuilder . All tests should continue to pass. public class AccountTestBuilder {\n    private final Integer id;\n    private final BigDecimal total;\n\n    public AccountTestBuilder(Integer id, BigDecimal total) {\n        this.id = id;\n        this.total = total;\n    }\n\n    public Account build() {\n        return new Account(id, total);\n    }\n\n    // generates a valid, default account\n    public static AccountTestBuilder anAccount() {\n        return new AccountTestBuilder(1, BigDecimal.TEN);\n    }\n\n    public AccountTestBuilder withId(Integer id) {\n        return new AccountTestBuilder(id, total);\n    }\n\n    public AccountTestBuilder withTotal(BigDecimal total) {\n        return new AccountTestBuilder(this.id, total);\n    }\n\n    // helper method\n    public AccountTestBuilder withTotal(Integer total) {\n        return withTotal(new BigDecimal(total));\n    }\n} To sum up, keep your tests as abstract as possible. Make use of the builder pattern and create functions to help you on that.", "tags": "java tdd test", "title": "Writing Better Tests In Java - Atomic Reference"}, {"url": "https://vrcca.github.io/post/my-first-post/", "text": "Hello world! Here is my first post. I shall begin it explaining how I setup this blog using GitHub Pages, GitLab and Hugo. Creating a new GitHub Pages To setup a new GitHub page, the website tutorial is pretty straightforward, so I will skip this. Hugo Hugo is a static website generator built on Go. It is extremely fast and requires little setup to start using it. To install it is as simple as: MacOS brew install hugo Linux apt install hugo or snap install hugo Hugo has many themes you can choose. For this post I will use Pixyll which is the same I used for this blog. It has support to Google Analytics, Markdown and Disqus integration, which is something I was looking for. Up and running After installing Hugo, you can create a new site with: $ hugo new site my-new-blog And you can start a server with: $ hugo server This will build all static files and keep an eye on any updates you do in your posts. To create a new post just type: $ hugo new post file-name Installing a theme You can follow the instructions of the theme, but usually it goes like this: $ cd my-new-blog\n$ git clone https://github.com/azmelanar/hugo-theme-pixyll.git themes/hugo-theme-pixyll\n\n# Copies default configurations from themes to your new site\n$ cp -R themes/hugo-theme-pixyll/exampleSite/config.toml ./config.toml After that, it\u2019s important for you to edit the file config.toml and properly set your name, baseUrl, GitHub page, etc. You can run hugo server to make sure that it works properly. Manually deploying your changes to GitHub pages After creating your GitHub Pages, clone it in the parent directory that has your new hugo website. Then you will have to copy all static files from your hugo website to the GitHub pages repository, commit and push the changes. You can manually deploy your new blog with the following commands: # Generates the static files required by GitHub pages\n$ hugo -d ../my-new-blog.github.io/\n$ cd ../my-new-blog.github.io/\n$ git commit -am \"My new blog\"\n$ git push If you try to access your GitHub pages, you should see it working as it would locally. Automatically building & deploying from GitLab If you are like me, you probably don\u2019t want to remember to type the commands above for each post. So I researched how to automatically generate a new blog version automatically, but the solution ends up either creating a deploy.sh script to manually run it or use CI. We are going to do the latter with GitLab CI . Why GitLab? It has free private repositories; CI/CD built-in; Kanban boards; WebIDE (you can create your blog posts in your browser. No need to install hugo.) Free private groups; and more! Let\u2019s start by creating our GitLab repository first: Create a new user account in GitLab for free. Create a new project with whatever name you like. Here I made my repository private, but it is up to you to decide. Clone the repository locally and push the files from your hugo setup. Now we need to tell GitLab to install Hugo, build our static files and deploy them to GitHub (just like we would do manually). Like I said before, we are going to use GitLab CI.\nTo setup GitLab CI it\u2019s pretty simple, just add a file named .gitlab-ci.yml to the root of your GitLab project, and it should start building. This file is used to tell GitLab how to build your repository. The steps we need to reproduce in GitLab basically are install, build and deploy: Somehow install Hugo somewhere; With the files from our GitLab repository, automatically build our blog; Deploy the generated files to GitHub; Our build will have two phases: build and deploy. So add this to the top of your .gitlab-ci.yml : stages:\n  - build\n  - deploy The stages property is used so you can make GitLab follow the given order when running your build steps. In this case, it will run all the steps that has build set to stage property, then deploy . Installing Hugo in GitLab CI All builds in GitLab run within a docker container, therefore, if your container run linux, you can run any Linux command in it. You can install Hugo and build your blog by adding this to our .gitlab-ci.yml : build:\n  stage: build\n  before_script:\n    - curl -L -o hugo.deb https://github.com/gohugoio/hugo/releases/download/v0.49.2/hugo_0.49.2_Linux-64bit.deb\n    - dpkg -i hugo.deb\n  script:\n    - mkdir -p build/ && hugo -d build/\n  artifacts:\n    name: 'blog-$CI_COMMIT_REF_NAME'\n    expire_in: 1 day\n    paths:\n      - build/ The artifacts step tells GitLab that, after this whole step finishes, you want to keep the build/ folder for a single day. This is useful in case you want to rollback changes or debug what your CI is doing. Automatically Deploying to GitHub Pages Now that we have installed Hugo and generated our static website, we need to deploy to GitHub. Deploying to GitHub requires us to clone our git repository from GitHub, copy our new build to it, and commit and pushing the changes. deploy:\n  stage: deploy\n  before_script:\n    - git clone https://githubusername:$GITHUB_ACCESS_TOKEN@github.com/githubusername/newblog.github.io.git blog-github/\n    - git config --global user.name \"AuthorName\"\n    - git config --global user.email \"email@myemail.com\"\n  script:\n    - rm -rf blog-github/content/\n    - cp -R build/* blog-github/\n    - cd blog-github/\n    - git diff --quiet && git diff --staged --quiet || git commit -am \"$CI_COMMIT_TITLE\" && git push\n  dependencies:\n    - build The before_script clones your repository with an user and password. The $GITHUB_ACCESS_TOKEN variable could be replaced with your GitHub\u2019s password, but we don\u2019t want to expose that. We will revisit it later. It also sets your name and email for future commits. The scripts steps does this: Removes the content/ folder. This is needed because you would never be able to rename or remove a post otherwise. Copies all static content from the build/ folder generated in the the previous step (see dependencies property) to the GitHub directory. The fourth step only adds and commits files if there are any changes in your git diff command. That\u2019s why we run a command with || . If there is no diff, there is no need to push things. The dependencies property tells GitLab that this step has dependencies with the build step. This enables us to reference files generated in other builds and maps a dependency graph between steps. After adding all this to .gitlab-ci.yml and commiting to GitLab, the build should be broken, but you should see that the CI/CD Pipelines are now being triggered on changes. We still need to set the $GITHUB_ACCESS_TOKEN variable. Defining GitLab CI Environment Variables We don\u2019t want to expose our passwords in files, because other people could have access to it. If you are the only person that will ever have access to this repository, then you can ignore all this and just replace the variable in your configuration file. However, it is STRONGLY advised to keep your secrets somewhere safe. Steps You can skip the steps below and go right to the page to create a token here . In your GitHub, go to Settings On the left bottom, click Developer Settings Then Personal access tokens Click on Generate new token Select public_repo Finally, Click Generate token With your new token, go to your repository in GitLab. Click on Settings Then CI / CD Expand the Variables section. For variable name, type GITHUB_ACCESS_TOKEN For the value, enter the new token. Mark it as Protected Save variables If you try to run your pipeline now, it should pass correctly. You should also see that your changes are now being pushed to your GitHub pages and that your website is now being correctly displayed. I hope this helps! Thanks for reading my first post!", "tags": "blog gitlab hugo", "title": "Hello World! - Atomic Reference"}, {"url": "https://vrcca.github.io/post/getting-the-current-page-in-phoenix/", "text": "When programming in Phoenix Framework , you sometimes need to code a decision point based on the current page. To do this, we can make use of Plug.Conn\u2019s path_info field and compare it with Routes . Let\u2019s say you have the following piece of code: <%= if is_accounts_page(@conn) %>\n    <div>\n        # Account related content\n    </div>\n<% end %> To find out if the user is in the account route, you can compare the current path with the Account page route in LayoutView : def is_accounts_page(conn = %Plug.Conn{path_info: path_info}) do\n  path_info\n  |> join_path()\n  |> String.equivalent?(Routes.accounts_path(conn, :index))\nend\n\ndefp join_path(path_info), do: \"/\" <> Enum.join(path_info, \"/\") As we can see, in the first line we extract the path_info from conn . Then we join all path parts into a single string. Finally, we compare the current path with the Routes.accounts_path . You can go even further and make this function work for any page by passing the route path as argument. I hope it helps. Please, let me know what you thought about this approach.", "tags": "elixir phoenix phoenixframework", "title": "Getting The Current Page in Phoenix Framework - Atomic Reference"}]};